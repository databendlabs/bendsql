/*
 * Copyright 2021 Datafuse Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export declare class ValueOptions {
  variantAsObject: boolean
}
export declare class Client {
  /** Create a new databend client with a given DSN. */
  constructor(dsn: string, opts?: ValueOptions | undefined | null)
  /** Get a connection from the client. */
  getConn(): Promise<Connection>
}
export declare class Connection {
  /** Get the connection information. */
  info(): Promise<ConnectionInfo>
  /** Get the databend version. */
  version(): Promise<string>
  formatSql(sql: string, params?: Params | undefined | null): string
  /** Execute a SQL query, return the number of affected rows. */
  exec(sql: string, params?: Params | undefined | null): Promise<number>
  /** Execute a SQL query, and only return the first row. */
  queryRow(sql: string, params?: Params | undefined | null): Promise<Row | null>
  /** Execute a SQL query and fetch all data into the result */
  queryAll(sql: string, params?: Params | undefined | null): Promise<Array<Row>>
  /** Execute a SQL query, and return all rows. */
  queryIter(sql: string, params?: Params | undefined | null): Promise<RowIterator>
  /** Execute a SQL query, and return all rows with schema and stats. */
  queryIterExt(sql: string, params?: Params | undefined | null): Promise<RowIteratorExt>
  /**
   * Load data with stage attachment.
   * The SQL can be `INSERT INTO tbl VALUES` or `REPLACE INTO tbl VALUES`.
   */
  streamLoad(sql: string, data: Array<Array<string>>): Promise<ServerStats>
  /**
   * Load file with stage attachment.
   * The SQL can be `INSERT INTO tbl VALUES` or `REPLACE INTO tbl VALUES`.
   */
  loadFile(sql: string, file: string, formatOptions?: Record<string, string> | undefined | null, copyOptions?: Record<string, string> | undefined | null): Promise<ServerStats>
}
export declare class ConnectionInfo {
  get handler(): string
  get host(): string
  get port(): number
  get user(): string
  get database(): string | null
  get warehouse(): string | null
}
export declare class Schema {
  fields(): Array<Field>
}
export declare class Field {
  get name(): string
  get dataType(): string
}
export declare class RowIterator {
  /** Get Schema for rows. */
  schema(): Schema
  /**
   * Fetch next row.
   * Returns `None` if there are no more rows.
   */
  next(): Promise<Error | Row | null>
  /**
   * Return a Readable Stream for the query result.
   * Should be used with `ObjectMode` set to `true`.
   */
  stream(): import('stream').Readable
}
export declare class RowIteratorExt {
  schema(): Schema
  /**
   * Fetch next row or stats.
   * Returns `None` if there are no more rows.
   */
  next(): Promise<Error | RowOrStats | null>
}
/** Must contain either row or stats. */
export declare class RowOrStats {
  get row(): Row | null
  get stats(): ServerStats | null
}
export declare class Row {
  setOpts(opts: ValueOptions): void
  values(): Array<any>
  data(): Record<string, any>
}
export declare class ServerStats {
  get totalRows(): bigint
  get totalBytes(): bigint
  get readRows(): bigint
  get readBytes(): bigint
  get writeRows(): bigint
  get writeBytes(): bigint
  get spillFileNums(): bigint
  get runningTimeMs(): number
}
